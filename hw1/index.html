<html>
  <head>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      h1 {
        text-align: center;
      }

      .container {
        margin: 0 auto;
        padding: 60px 20%;
      }

      figure {
        text-align: center;
      }

      img {
        display: inline-block;
      }

      body {
        font-family: "Inter", sans-serif;
      }
      .comparison-table {
        width: 100%;
        border-collapse: collapse;
        font-family: Arial, sans-serif;
        margin: 20px 0;
      }
      .comparison-table th,
      .comparison-table td {
        border: 1px solid #ddd;
        padding: 12px;
        text-align: left;
        vertical-align: top;
      }
      .comparison-table th {
        background-color: #f4f4f4;
        font-weight: bold;
      }
      .comparison-table tr:nth-child(even) {
        background-color: #f9f9f9;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
      <div style="text-align: center">Names: Sun Jingfeng</div>

      <br />

      Link to webpage:
      <a href="https://jingfengs.github.io/cs184-284a-sp25-hw-webpages/"
        >https://jingfengs.github.io/cs184-284a-sp25-hw-webpages/</a
      >

      <br />

      Link to GitHub repository: (TODO)
      <a href="https://github.com/JingfengS/cs184-284a-sp25-hw-webpages"
        >https://github.com/JingfengS/cs184-284a-sp25-hw-webpages</a
      >

      <figure>
        <img src="lion.jpg" alt="Lion" style="width: 50%" />
      </figure>

      <!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

      <h2>Overview</h2>
      This is my self-implemented functional vector graphics renderer that can
      take in a simplified version of SVG (Scalable Vector Graphics) file, which
      contains features such as drawing triangles, supersampling, hierarchical
      transforms, and texture mapping with antialiasing.

      <h2>Task 1: Drawing Single-Color Triangles</h2>
      For this task, I first implemented a basic drawing algorithm, which worked
      but slow in speed. Then I made 2 optimazations to make it faster. Finally,
      I used several test images to test my implementation and see significant
      improvement.

      <h3>Basic Implementation</h3>
      Use the 3 vertex points to find out the bounding box of the triangle. Then
      for every pixel inside the bounding box, find out if it is inside the
      triangle by checking its position relative to the 3 edges of the triangle.
      This method is intuitive but lack in efficiency.

      <h3>First Optimization</h3>
      Finding if a single point P is inside the triangle requires checking its
      position relative to 3 edges, which involves 3 cross products and 3
      multiplications. However, for the pixels in the same row or same column,
      its cross products share common terms, which only requires one single
      addition to update from one pixel to its neighbor. To optimize this, I
      precompute the edge functions for the triangle, which allows me to
      iterating over pixels in a scanline order and updating the edge function
      values incrementally. This reduces reduncdant calculations and improves
      efficiency.

      <h3>Second Optimization</h3>
      However, iterating over every pixel in the bounding box is still
      inefficient, especially when the triangle is small compared to the
      bounding box. In the iterating process, I found out that for a line, if it
      enters the triangle and then exit it, all the following pixels in that row
      will be outside the triangle. Therefore, I can break out of the inner loop
      early when I detect that the line has exited the triangle. This
      optimization significantly reduces the number of pixels that need to be
      checked, especially for small triangles.

      <h3>Speed Test results</h3>

      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="assets/task1/dragon.png" width="400px" />
              <figcaption>Basic: 9.1106ms</figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task1/dragon.png" width="400px" />
              <figcaption>First Optimization: 7.9026ms</figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task1/dragon.png" width="400px" />
              <figcaption>Second Optimization: 6.7875ms</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="assets/task1/drawing_sample.png" width="400px" />
              <figcaption>Basic: 66.367ms</figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task1/drawing_sample.png" width="400px" />
              <figcaption>First Optimization: 51.139ms</figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task1/drawing_sample.png" width="400px" />
              <figcaption>Second Optimization: 30.547ms</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="assets/task1/drawing_sample_2.png" width="400px" />
              <figcaption>Basic: 658.75ms</figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task1/drawing_sample_2.png" width="400px" />
              <figcaption>First Optimization: 486.67ms</figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task1/drawing_sample_2.png" width="400px" />
              <figcaption>Second Optimization: 343.02ms</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <h2>Task 2: Antialiasing by Supersampling</h2>
      <figure>
        <img
          src="assets/task2/super_sampling.png"
          alt="Lion"
          style="width: 50%"
        />
      </figure>
      <h3>Overview</h3>
      In this section, to antialiasing, I implemented supersampling, which
      involves dividing each pixel into a grid of subpixels, sampling the
      subpixels to see if they are covered by any triangle, and averaging the
      colors of the subpixels to determine the final color of the pxiel. By
      doing so, we can achieve smoother edges and reduce aliasing artifacts in
      the rendered image.
      <h3>Data Structures</h3>
      <ul>
        <li>
          <strong>Sample rate:</strong> An integer to indicate the number of
          subpixels per pixel, which takes values of 1, 4, 9 etc.
        </li>
        <li>
          <strong>Samplebuffer:</strong> An array of size (width * height *
          sample_rate) to store the color values of each subpixels.
        </li>
        <li>
          <strong>Framebuffer: </strong> An array of size (width * height) to
          store the resolved color values of each pixel from the sample buffer.
        </li>
      </ul>
      <h3>Implementation Details</h3>
      During the rasterization process, instead of checking if the center of the
      pixel is inside the triangle, I check each subpixel within the pixel. For
      each subpixel, I calculate its position based on the sample rate and
      determine if it is covered by the triangle using the same edge function
      method as in Task 1. If a subpixel is covered, I set its color in the
      sample buffer to the triangle's color. After rasterizing all triangles, I
      resolve the final color of each pixel by averaging the colors of its
      subpixels in the sample buffer. This involves summing up the color values
      of all subpixels within a pixel and dividing by the total number of
      subpixels (i.e., sample rate). The resolved color is then stored in the
      framebuffer, which is used to generate the final output image.

      <h3>Results</h3>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="assets/task2/blue-1.png" width="400px" />
              <figcaption>Sample Rate: 1</figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task2/blue-4.png" width="400px" />
              <figcaption>Sample Rate: 4</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="assets/task2/blue-9.png" width="400px" />
              <figcaption>Sample Rate: 9</figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task2/blue-16.png" width="400px" />
              <figcaption>Sample Rate: 16</figcaption>
            </td>
          </tr>
        </table>
      </div>
      <p>
        <strong
          >As the sample rate increases, the image becomes less pixelated and
          smoother.</strong
        >
      </p>

      <h2>Task 3: Transforms</h2>
      <h3>Overview</h3>
      In this task, I added transform features to the renderer. Including
      translation, scaling, and rotation. In addition to that, you can use `R`
      to rotate the whole image.
      <h3>Results</h3>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="assets/task3/robot.png" width="400px" />
              <figcaption>Robot</figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task3/robot-waiving.png" width="400px" />
              <figcaption>Robot Waiving (Change the svg file)</figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task3/rotate.png" width="400px" />
              <figcaption>Extra: Rotate the whole image</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <h2>Task 4: Barycentric coordinates</h2>
      <h3>Overview</h3>
      Before apply texture mapping, each vertex of the triangle has texture
      coordinates \( (u, v) \). However, for a pixel P inside the triangle, we
      need to assign it a texture coordinate as well. To do this, we can assign
      \( (u_p, v_p) \) based on the three vertexes \( (u_1, v_1), (u_2, v_2),
      (u_3, v_3) \). Finally, we can derive: \[ u_p = \alpha u_1 + \beta u_2 +
      \gamma u_3 \] \[ v_p = \alpha v_1 + \beta v_2 + \gamma v_3 \] where \(
      \alpha, \beta, \gamma \) are the barycentric coordinates of point P with
      respect to the triangle.
      <figure>
        <img
          src="assets/task4/BaryCoord.png"
          alt="Barycentric Coordinates"
          style="width: 50%"
        />
        <figcaption>Figure: Barycentric Coordinates</figcaption>
      </figure>
      <h3>Results</h3>
      <figure>
        <img
          src="assets/task4/task4.png"
          alt="Interpolated Results"
          style="width: 50%"
        />
        <figcaption>Figure: Interpolated Results</figcaption>
      </figure>

      <h2>Task 5: "Pixel sampling" for texture mapping</h2>
      <h3>Overview</h3>
      Pixel sampling is the process of determining the color of a pixel based on
      the information provided by a texture map. In this task, we are mapping a
      3D geomatry (which is projected onto a 2D grid of pixels in the screen) to
      a 2D texture image. Because the screen pixels and the texture image pixels
      almost never align 1:1, we have to "sample" the texture image to figure
      out what color a specific pixel should be.

      <h3>Implementation Steps</h3>
      <ol>
        <li>
          Calculate the barycentric coordinates \( \alpha, \beta, \gamma \) for
          the pixel, and use them to interpolate the texture coordinates \(
          (u_p, v_p) \).
        </li>
        <li>
          This resulting uv clirresplinds tli a relative plisitilin in the
          texture (range frlim 0.0 tli 1.0), thus scaling these by the width and
          height lif the texture image.
        </li>
        <li>
          Use bilinear interpolation or nearest-neighbor sampling to determine
          the color at the calculated texture coordinates.
        </li>
      </ol>
      <h4>Nearest vs Bilinear Sampling</h4>
      <ul>
        <li>
          <strong>Nearest-Neighbor Sampling:</strong>This is the simplest
          method. It takes the specific \( (u, v) \) coordinate, scales it to
          the texture grid, and simply rounds to the nearest integer coordinates
          to find the closest texel. It then blindly returns the color of that
          single texel.
        </li>
        <li>
          <strong>Bilinear Sampling:</strong> This is a more sophisticated
          method. Instead of snapping to the single closest texel, it identifies
          the four nearest texels surrounding the sample point. It then computes
          a weighted average (linear interpolation) of these four colors based
          on how close the sample point is to the center of each texel. This
          results in a smooth blend.
        </li>
      </ul>
      <h3>Visual Comparison</h3>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="assets/task5/nearest-1.png" width="400px" />
              <figcaption>
                Nearest-Neighbor Sampling (sample rate: 1 pixel)
              </figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task5/bilinear-1.png" width="400px" />
              <figcaption>Bilinear Sampling (sample rate: 1 pixel)</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="assets/task5/nearest-16.png" width="400px" />
              <figcaption>
                Nearest-Neighbor Sampling (sample rate: 16 pixel)
              </figcaption>
            </td>
            <td style="text-align: center">
              <img src="assets/task5/bilinear-16.png" width="400px" />
              <figcaption>Bilinear Sampling (sample rate: 16 pixel)</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <h3>Observations</h3>
      <ul>
        <li>
          Nearest-Neighbor Sampling tends to produce a blocky, pixelated
          appearance, especially at lower sample rates. This is because it
          selects the color of the nearest texel without considering the
          surrounding texels.
        </li>
        <li>
          Bilinear Sampling results in a much smoother and more visually
          appealing image. By averaging the colors of the four nearest texels,
          it effectively reduces aliasing artifacts and creates a more
          continuous transition between colors.
        </li>
      </ul>

      <h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
      <h3>Overview</h3>
      Level sampling, often referred to as Mipmapping, is a technique used to
      handle texture aliasing when an object is far away from the camera
      (minification).
      <br />
      Suppose we have a high resolution texture image that we want to map onto a
      3D object. When the object is close to the camera, we can use the original
      texture without any issues. However, as the object moves further away, the
      texture appears smaller on the screen, and multiple texels may map to a
      single pixel. This can lead to aliasing artifacts, where high-frequency
      details in the texture cause visual noise.

      <br />

      Level sampling solves this by pre-computing lower-resolution versions of
      the texture (a pyramid of images).
      <ul>
        <li>Level 0 is the full resolution.</li>
        <li>Level 1 is half resolution (averaged down).</li>
        <li>Level 2 is quarter resolution, and so on.</li>
      </ul>
      When rendering, we calculate how much "space" a screen pixel takes up on
      the texture. If the pixel covers a large area of the texture, we simply
      switch to a higher, blurrier Level (like Level 3 or 4). This acts as a
      pre-computed low-pass filter, ensuring we get an average color of the area
      rather than a random noise point.

      <h3>Implementation Steps</h3>
      <ol>
        <li>
          I calculated the texture coordinates \((u, v)\) for the current pixel
          \((x, y)\).
        </li>
        <li>
          I also calculated the coordinates for its immediate neighbors: \((x+1,
          y)\) and \((x, y+1)\).
        </li>
        <li>
          I computed the difference vectors: \(\frac{du}{dx}, \frac{dv}{dx}\)
          (change in texture per screen-width step) and \(\frac{du}{dy},
          \frac{dv}{dy}\) (change in texture per screen-height step).
        </li>
        <li>
          I used the maximum length of these vectors to determine the scale
          factor \(L\). \[L = \left( \max \left( \sqrt{\left( \frac{du}{dx}
          \right)^2 + \left( \frac{dv}{dx} \right)^2}, \sqrt{\left(
          \frac{du}{dy} \right)^2 + \left( \frac{dv}{dy} \right)^2} \right)
          \right) \]
        </li>
        <li>Finally, the Mipmap Level \(D\) is calculated as \(\log_2(L)\).</li>
      </ol>
      <h3>Comparison between sampling techniques</h3>

      <table class="comparison-table">
        <thead>
          <tr>
            <th>Technique</th>
            <th>Speed</th>
            <th>Memory Usage</th>
            <th>Antialiasing Power</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              <strong>Pixel Sampling</strong><br />
              <small>(P_NEAREST / P_LINEAR)</small>
            </td>
            <td><strong>Fastest.</strong> Simple arithmetic.</td>
            <td><strong>Lowest.</strong> Stores only the base texture.</td>
            <td>
              <strong>Weak.</strong> Good for magnification (zoomed in), but
              produces severe Moire patterns and shimmering when zoomed out
              (minification).
            </td>
          </tr>
          <tr>
            <td>
              <strong>Level Sampling</strong><br />
              <small>(Mipmapping)</small>
            </td>
            <td>
              <strong>Fast.</strong> Slightly more math to compute derivatives,
              but much more cache-friendly than supersampling.
            </td>
            <td>
              <strong>Moderate.</strong> Requires ~33% more memory to store the
              mipmap pyramid (the sum of 1/4 + 1/16 + ... &approx; 1/3).
            </td>
            <td>
              <strong>Excellent for Textures.</strong> Efficiently removes
              aliasing/shimmering on textured surfaces at a distance. Does not
              help with geometric edges.
            </td>
          </tr>
          <tr>
            <td>
              <strong>Supersampling</strong><br />
              <small>(Number of Samples)</small>
            </td>
            <td>
              <strong>Slowest.</strong> Speed decreases linearly with the number
              of samples (16x samples = ~16x slower).
            </td>
            <td>
              <strong>Highest.</strong> Requires a sample buffer
              <em>N</em> times larger than the screen resolution.
            </td>
            <td>
              <strong>Best Overall.</strong> The only method here that fixes
              geometric aliasing (jaggies on triangle edges) and texture
              aliasing (though inefficiently).
            </td>
          </tr>
        </tbody>
      </table>
      <h3>Visual Comparison</h3>
      <div style="display: flex; flex-direction: column; align-items: center">
        <table
          style="width: 100%; text-align: center; border-collapse: collapse"
        >
          <tr>
            <td style="text-align: center">
              <img src="assets/task6/p_nearest-level0.png" width="400px" />
              <figcaption>Level 0 (P_NEAREST)</figcaption>
            </td>
            <td style="text-align: center">
              <img
                src="assets/task6/p_nearest-level_nearest.png"
                width="400px"
              />
              <figcaption>Level Nearest (P_NEAREST)</figcaption>
            </td>
          </tr>
          <tr>
            <td style="text-align: center">
              <img src="assets/task6/p_bilinear-level0.png" width="400px" />
              <figcaption>Level 0 (P_BILINEAR)</figcaption>
            </td>
            <td style="text-align: center">
              <img
                src="assets/task6/p_bilinear-level-nearest.png"
                width="400px"
              />
              <figcaption>Level Nearest (P_BILINEAR)</figcaption>
            </td>
          </tr>
        </table>
      </div>

      <h3>Observations</h3>
      LEVEL ZERO methods result in aliasing when zoomed out.
      LEVEL NEAREST fixes the aliasing by substituting the blurry lower-level
      texture, which makes the texture look more smooth.
    </div>
  </body>
</html>
